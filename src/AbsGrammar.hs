

module AbsGrammar where

-- Haskell module generated by the BNF converter




newtype Ident = Ident {getIdent :: String} deriving (Eq, Ord, Show, Read)
newtype RelOp = RelOp String deriving (Eq, Ord, Show, Read)
newtype Basic = Basic String deriving (Eq, Ord, Show, Read)
data Expr
    = EInt Integer
    | EChar Char
    | EString String
    | EIdent Ident
    | ETrue
    | EFalse
    | EVoid
    | EEmpty
    | ENot Expr
    | ETuple Expr [Expr]
    | EList [Expr]
    | ELambda [Ident] Expr
    | EApp Expr Expr
    | EMul Expr Expr
    | EDiv Expr Expr
    | EAdd Expr Expr
    | ESub Expr Expr
    | EConcat Expr Expr
    | ENeg Expr
    | ERel Expr RelOp Expr
    | EAnd Expr Expr
    | EOr Expr Expr
    | EAppend Expr Expr
    | EUnion Expr Expr
    | EIf Expr Expr Expr
    | ELet Ident Expr Expr
    | EType Expr Type
  deriving (Eq, Ord, Show, Read)

gt, lt, ge, le, eq, neq :: RelOp
gt = RelOp ">"
lt = RelOp "<"
ge = RelOp ">="
le = RelOp "<="
eq = RelOp "=="
neq = RelOp "!="

data Type
    = TBasic Basic
    | TIdent Ident
    | TProduct Type Type
    | TUnion Type Type
    | TFun Type Type
    | TList Type
  deriving (Eq, Ord, Show, Read)

data TBasic = TInt | TChar | TBool | TVoid

matchBasic :: Basic -> TBasic
matchBasic (Basic s) = case s of
    "int" -> TInt
    "char" -> TChar
    "bool" -> TBool
    "void" -> TVoid


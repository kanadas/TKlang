Description:
Language is functional, static typed with type reconstruction, algebraic and recursive types and haskell-like syntax.
Type unions are indexed which means that value of type (int + char + unit) can be either of: 1@int_value, 2@char_value, 3@(). 
Language features also "stream" objects, which behave slightly different than in language proposal. Stream behaves like singleton objects. Every stream may have inputs that are also streams. Computation of stream begins when all its inputs compute. Stream has state and output which are normal values, but while computing may use output values of input streams, and values of state and output from previous computation. Every state and output value has to be initialized in "initial" section of stream. After computation of stream interpreter checks if there are new streams ready for computation, adds them at the end of queue, and starts computing stream from the front of queue. If queue is empty then interpreter chooses one of streams that have no inputs (they are kept on cyclic queue) and computes it.Input is realized by Input stream that have no inputs, and single output which has next character from standard input. If there is no stream that uses Input, it won't be executed.
Output is realized through Output stream, it's input is main stream and it uses 3 values: print to print next character, exit to end program execution (that's only way, besides reading eof character), break to force reading next character.
In language proposition was also name overloading, which I didn't manage to implement, every other declared feature is implemented. Grammar changed slightly from proposition (removed some conflicts, changed operator precedence to more intuitive and added "initial" section to streams), and its final version is provided in file Grammar.cf in BNFC format.

Final features:
    - Basic types: int, char, bool, unit
    - Basic (int and bool) arithmetic, comparisons, let ... in, if ... then ... else ...
    - Anonymous and named functions, recursion, partial application, higher-level functions
    - Runtime error handling
    - Algebraic, recursive types, type aliases
    - Static name binding
    - Static typing, type reconstruction
    - Multi-level pattern matching
    - Syntax sugar for lists: constructors and patterns: head:tail, [items], [type]
    - Streams
    - Input/Output realized by streams

Materials:
Lexer and parser generated by BNFC: https://bnfc.digitalgrammars.com/
Type unification algorithm: http://dev.stephendiehl.com/fun/006_hindley_milner.html

